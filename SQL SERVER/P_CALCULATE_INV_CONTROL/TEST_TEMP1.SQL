--來測試資料對不對，先寫一個TEMP1 跟執行P_CALC_MAX_LEVEL12
WITH parent as( 
select INV_ENTITY_CODE AS entity,
ENTITY_CODE AS parent,
1 AS ratio FROM TRS_FACT_GROUP_INV_REL 
WHERE RATIO_HOLD >=0.5
--判斷是否為母公司
AND CAST('2023-12-31'AS DATE) BETWEEN START_DATE AND END_DATE
--日期在起訖日間
)
,PARENT_ROUTE(ROUTES_ID,STARTING_ENTITY, entity, PARENT, ratio, LEVELS) AS (
SELECT 
  CAST(entity + '-' + PARENT AS VARCHAR(255)) AS ROUTES_ID,
  ENTITY AS STARTING_ENTITY,
  entity,
  PARENT,
  ratio,
  1 AS LEVELS
  FROM PARENT
  WHERE ENTITY = 'OAKWOOD_3' --用參數控制
UNION ALL
  SELECT 
  CAST(ip.ROUTES_ID + '-' + i.PARENT AS VARCHAR(255)) AS ROUTES_ID ,
  ip.STARTING_ENTITY,
  i.entity,
  i.PARENT,
  i.ratio ,
  ip.levels + 1 AS LEVELS
  FROM PARENT i --持股事實表
  JOIN PARENT_ROUTE ip ON ip.PARENT = i.entity
  )--SELECT * FROM PARENT_ROUTE
  ,RELATIONS AS (
  SELECT 
  ENTITY_CODE  AS ENTITY,
  INV_ENTITY_CODE AS RELATION,
  CAST(1 AS DECIMAL(24,7)) AS RATIO
  FROM TRS_FACT_REL_PARTY_INFO 
  WHERE ENTITY_CODE = 'OAKWOOD_3' --用參數控制
  AND PERIOD = YEAR(CAST('2023-12-31'AS DATE))
--  判斷當年度是否為關係人
  ) --SELECT * FROM RELATIONS
  ,INVEST1 AS(
  SELECT 
  CAST(t1.ENTITY_CODE AS VARCHAR(255)) AS ENTITY,
  CAST(t1.INV_ENTITY_CODE AS VARCHAR(255)) AS INV_ENTITY,
--  避免VARCHAR和NVARCHAR不能UNION的問題
  t1.RATIO_HOLD AS RATIO
  FROM TRS_FACT_GROUP_INV_REL t1
  LEFT JOIN PARENT_ROUTE t2 ON t1.ENTITY_CODE = t2.PARENT AND t1.INV_ENTITY_CODE = t2.ENTITY
  WHERE t2.ENTITY IS NULL
  AND INV_ENTITY_CODE NOT IN (SELECT PARENT FROM PARENT_ROUTE)
  AND INV_ENTITY_CODE != 'OAKWOOD_3'
  AND CAST('2023-12-31'AS DATE) BETWEEN START_DATE AND END_DATE
   UNION ALL
  SELECT 
  ENTITY,
  RELATION,
  RATIO
  FROM RELATIONS
  UNION ALL
   SELECT 
  CAST(ENTITY AS VARCHAR(255)),
  CAST(PARENT AS VARCHAR(255)),
  --  避免VARCHAR和NVARCHAR不能UNION的問題
  RATIO
  FROM PARENT_ROUTE)
  ,INVEST_ROUTE(ROUTES_ID,STARTING_ENTITY, entity, inv_entity, ratio, LEVELS) AS ( --遞迴一得到持股路徑
  SELECT 
  CAST(entity+'-'+inv_entity AS VARCHAR(255)) AS ROUTES_ID,
  entity AS STARTING_ENTITY,
  entity,
  inv_entity,
  ratio,
  1 AS LEVELS
  FROM INVEST1
  WHERE  ENTITY = 'OAKWOOD_3' --用參數控制
UNION ALL
SELECT 
  CAST(ip.ROUTES_ID+'-'+i.inv_entity AS VARCHAR(255)) AS ROUTES_ID ,
  ip.STARTING_ENTITY,
  i.entity,
  i.inv_entity,
  i.ratio ,
  ip.levels + 1 AS LEVELS
  FROM Invest1 i --持股事實表
  JOIN INVEST_ROUTE ip ON ip.inv_entity = i.entity
)
,T1 AS( --找路徑最大層
SELECT 
ROUTES_ID,
STARTING_ENTITY, 
entity, 
inv_entity, 
ratio, 
LEVELS,
MAX(LEVELS)OVER(PARTITION BY starting_entity,entity,inv_entity) AS MAX_LEVEL,
MAX(ROUTES_ID)OVER(PARTITION BY starting_entity,entity,inv_entity,LEVELS) AS MAX_ROUTE,
CASE WHEN MAX(LEVELS)OVER(PARTITION BY starting_entity,entity,inv_entity) != LEVELS THEN 'N'
    WHEN MAX(LEVELS)OVER(PARTITION BY starting_entity,entity,inv_entity) = LEVELS AND MAX(ROUTES_ID)OVER(PARTITION BY starting_entity,entity,inv_entity,LEVELS) != ROUTES_ID THEN 'N'
    ELSE 'Y' END AS KEEP --判斷數據是否要留
FROM INVEST_ROUTE
),T2 AS( --篩出保留路徑
SELECT
ROUTES_ID,
starting_entity, 
entity, 
inv_entity, 
ratio, 
levels,
MAX_LEVEL,
MAX(LEVELS)OVER(PARTITION BY STARTING_ENTITY,INV_ENTITY) AS MAX_INV_LEVEL
FROM T1
WHERE 1=1
AND KEEP = 'Y'
)
,T2_DEFER(ROUTES_ID,STARTING_ENTITY, entity, inv_entity, ratio, LEVELS, MAX_INV_LEVEL) AS( --遞迴二 層級遞延切齊
SELECT
ROUTES_ID,
STARTING_ENTITY, 
entity, 
inv_entity, 
ratio, 
LEVELS,
MAX_INV_LEVEL
FROM T2
UNION ALL 
SELECT
CAST(ROUTES_ID + '-' + INV_ENTITY AS VARCHAR(255)) AS ROUTES_ID,
STARTING_ENTITY, 
inv_entity AS entity, 
inv_entity, 
ratio, 
levels+1 AS LEVELS,
MAX_INV_LEVEL
FROM T2_DEFER
WHERE LEVELS+1 <= MAX_INV_LEVEL
)



INSERT INTO TEMP1
SELECT 
ROUTES_ID,
STARTING_ENTITY, 
entity, 
inv_entity, 
ratio, 
LEVELS,
MAX_INV_LEVEL
FROM T2_DEFER


TRUNCATE TABLE TEMP1
EXEC P_CALC_MAX_LEVEL1