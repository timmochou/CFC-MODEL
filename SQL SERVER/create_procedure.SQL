CREATE PROCEDURE P_CAL_RATIO_HOLD
AS
BEGIN
	SELECT GETDATE() AS UPDATE_TIME;
    DECLARE 
        @ID VARCHAR(50),
        @CFC_ENTITY_CODE VARCHAR(50),          -- 根据实际数据类型和长度调整
        @CFC_INV_ENTITY_CODE VARCHAR(50),      -- 根据实际数据类型和长度调整
        @DECLARATION_DATE DATE;

    DECLARE rec_cursor CURSOR FOR
    SELECT 
    	ID,
        t2.CURRENT_CODE AS CFC_ENTITY_CODE, 
        t3.CURRENT_CODE AS CFC_INV_ENTITY_CODE, 
        DECLARATION_DATE
    FROM TRS_FACT_CFC_INV_DIVIDEND t1
    LEFT JOIN V_TRS_DIM_ENTITY_CUR t2 ON t1.CFC_ENTITY_CODE = t2.ENTITY_CODE
    LEFT JOIN V_TRS_DIM_ENTITY_CUR t3 ON t1.CFC_INV_ENTITY_CODE = t3.ENTITY_CODE
     ;

    OPEN rec_cursor;

    FETCH NEXT FROM rec_cursor INTO 
        @ID,
    	@CFC_ENTITY_CODE, 
        @CFC_INV_ENTITY_CODE, 
        @DECLARATION_DATE;

    WHILE @@FETCH_STATUS = 0
    BEGIN
        -- 调用存储过程 P_GET_RATIO_HOLD
        EXEC P_GET_RATIO_HOLD @ID,@DECLARATION_DATE, @CFC_ENTITY_CODE, @CFC_INV_ENTITY_CODE;

        FETCH NEXT FROM rec_cursor INTO 
            @ID,
        	@CFC_ENTITY_CODE, 
            @CFC_INV_ENTITY_CODE, 
            @DECLARATION_DATE;
    END;

    CLOSE rec_cursor;
    DEALLOCATE rec_cursor;
END;

CREATE PROCEDURE P_CAL_RATIO_HOLD_NONLOWTAX_ADJ
AS
BEGIN
	SELECT GETDATE() AS UPDATE_TIME;
    DECLARE 
    	@ID VARCHAR(50),
        @CFC_ENTITY_CODE VARCHAR(255),    -- 根据实际数据类型和长度进行调整
        @INV_ENTITY_CODE VARCHAR(255),
        @DISPOSE_DATE DATE,
        @SELL_COMPANY VARCHAR(255);

    -- 声明游标
    DECLARE rec_cursor CURSOR FOR
    SELECT 
        ID,
   		t2.CURRENT_CODE AS CFC_ENTITY_CODE, 
        t3.CURRENT_CODE AS INV_ENTITY_CODE, 
        DISPOSE_DATE, 
        t4.CURRENT_CODE AS SELL_COMPANY
    FROM TRS_FACT_CFC_NONLOW_ADJ t1
    LEFT JOIN V_TRS_DIM_ENTITY_CUR t2 ON t1.CFC_ENTITY_CODE = t2.ENTITY_CODE
    LEFT JOIN V_TRS_DIM_ENTITY_CUR t3 ON t1.INV_ENTITY_CODE = t3.ENTITY_CODE
    LEFT JOIN V_TRS_DIM_ENTITY_CUR t4 ON t1.SELL_COMPANY = t4.ENTITY_CODE
     ;

    OPEN rec_cursor;

    FETCH NEXT FROM rec_cursor INTO 
    	@ID ,
        @CFC_ENTITY_CODE, 
        @INV_ENTITY_CODE, 
        @DISPOSE_DATE, 
        @SELL_COMPANY;

    WHILE @@FETCH_STATUS = 0
    BEGIN
        -- 调用存储过程 P_GET_RATIO_HOLD_NONLOWTAX_ADJ_1
        EXEC P_GET_RATIO_HOLD_NONLOWTAX_ADJ_1 @ID ,@DISPOSE_DATE, @CFC_ENTITY_CODE, @INV_ENTITY_CODE;

        -- 调用存储过程 P_GET_RATIO_HOLD_NONLOWTAX_ADJ_2
        EXEC P_GET_RATIO_HOLD_NONLOWTAX_ADJ_2 @ID ,@DISPOSE_DATE, @CFC_ENTITY_CODE, @SELL_COMPANY;

        FETCH NEXT FROM rec_cursor INTO 
        	@ID ,
            @CFC_ENTITY_CODE, 
            @INV_ENTITY_CODE, 
            @DISPOSE_DATE, 
            @SELL_COMPANY;
    END;

    CLOSE rec_cursor;
    DEALLOCATE rec_cursor;
END;

CREATE PROCEDURE P_CAL_RATIO_HOLD_REALIZED_LOSS
AS
BEGIN
	SELECT GETDATE() AS UPDATE_TIME;
    DECLARE 
    	@ID VARCHAR(50),
        @CFC_ENTITY_CODE VARCHAR(255),    -- 根据实际数据类型和长度进行调整
        @INV_ENTITY_CODE VARCHAR(255),
        @LOSS_DATE DATE;

    -- 声明游标
    DECLARE rec_cursor CURSOR FOR
    SELECT 
    	ID,
        t2.CURRENT_CODE AS CFC_ENTITY_CODE, 
        t3.CURRENT_CODE AS INV_ENTITY_CODE, 
        LOSS_DATE
    FROM TRS_FACT_CFC_REALIZED_LOSS t1
    LEFT JOIN V_TRS_DIM_ENTITY_CUR t2 ON t1.CFC_ENTITY_CODE = t2.ENTITY_CODE
    LEFT JOIN V_TRS_DIM_ENTITY_CUR t3 ON t1.INV_ENTITY_CODE = t3.ENTITY_CODE
   ;

    OPEN rec_cursor;

    FETCH NEXT FROM rec_cursor INTO 
    	@ID,
        @CFC_ENTITY_CODE, 
        @INV_ENTITY_CODE, 
        @LOSS_DATE;

    WHILE @@FETCH_STATUS = 0
    BEGIN
        -- 调用存储过程 P_GET_RATIO_HOLD_REALIZED_LOSS
        EXEC P_GET_RATIO_HOLD_REALIZED_LOSS @ID, @LOSS_DATE, @CFC_ENTITY_CODE, @INV_ENTITY_CODE;

        FETCH NEXT FROM rec_cursor INTO 
        	@ID,
            @CFC_ENTITY_CODE, 
            @INV_ENTITY_CODE, 
            @LOSS_DATE;
    END;

    CLOSE rec_cursor;
    DEALLOCATE rec_cursor;
END;

CREATE PROCEDURE P_CALCULATE_INV_CONTROL @PARA VARCHAR(255), @P_DATE DATE AS
BEGIN
WITH parent as( 
select INV_ENTITY_CODE AS entity,
ENTITY_CODE AS parent,
1 AS ratio FROM TRS_FACT_GROUP_INV_REL 
WHERE RATIO_HOLD >=0.5
--判斷是否為母公司
AND @P_DATE BETWEEN START_DATE AND END_DATE
--日期在起訖日間
)
,PARENT_ROUTE(ROUTES_ID,STARTING_ENTITY, entity, PARENT, ratio, LEVELS) AS (
SELECT 
  CAST(entity + '-' + PARENT AS VARCHAR(255)) AS ROUTES_ID,
  ENTITY AS STARTING_ENTITY,
  entity,
  PARENT,
  ratio,
  1 AS LEVELS
  FROM PARENT
  WHERE ENTITY = @PARA --用參數控制
UNION ALL
  SELECT 
  CAST(ip.ROUTES_ID + '-' + i.PARENT AS VARCHAR(255)) AS ROUTES_ID ,
  ip.STARTING_ENTITY,
  i.entity,
  i.PARENT,
  i.ratio ,
  ip.levels + 1 AS LEVELS
  FROM PARENT i --持股事實表
  JOIN PARENT_ROUTE ip ON ip.PARENT = i.entity
  )--SELECT * FROM PARENT_ROUTE
  ,RELATIONS AS (
  SELECT 
  ENTITY_CODE  AS ENTITY,
  INV_ENTITY_CODE AS RELATION,
  CAST(1 AS DECIMAL(24,7)) AS RATIO
  FROM TRS_FACT_REL_PARTY_INFO 
  WHERE ENTITY_CODE = @PARA --用參數控制
  AND PERIOD = YEAR(@P_DATE)
--  判斷當年度是否為關係人
  ) --SELECT * FROM RELATIONS
  ,INVEST1 AS(
  SELECT 
  CAST(t1.ENTITY_CODE AS VARCHAR(255)) AS ENTITY,
  CAST(t1.INV_ENTITY_CODE AS VARCHAR(255)) AS INV_ENTITY,
--  避免VARCHAR和NVARCHAR不能UNION的問題
  t1.RATIO_HOLD AS RATIO
  FROM TRS_FACT_GROUP_INV_REL t1
  LEFT JOIN PARENT_ROUTE t2 ON t1.ENTITY_CODE = t2.PARENT AND t1.INV_ENTITY_CODE = t2.ENTITY
  WHERE t2.ENTITY IS NULL
  AND INV_ENTITY_CODE NOT IN (SELECT PARENT FROM PARENT_ROUTE)
  AND INV_ENTITY_CODE != @PARA
  AND @P_DATE BETWEEN START_DATE AND END_DATE
   UNION ALL
  SELECT 
  ENTITY,
  RELATION,
  RATIO
  FROM RELATIONS
  UNION ALL
   SELECT 
  CAST(ENTITY AS VARCHAR(255)),
  CAST(PARENT AS VARCHAR(255)),
  --  避免VARCHAR和NVARCHAR不能UNION的問題
  RATIO
  FROM PARENT_ROUTE)
  ,INVEST_ROUTE(ROUTES_ID,STARTING_ENTITY, entity, inv_entity, ratio, LEVELS) AS ( --遞迴一得到持股路徑
  SELECT 
  CAST(entity+'-'+inv_entity AS VARCHAR(255)) AS ROUTES_ID,
  entity AS STARTING_ENTITY,
  entity,
  inv_entity,
  ratio,
  1 AS LEVELS
  FROM INVEST1
  WHERE  ENTITY = @PARA --用參數控制
UNION ALL
SELECT 
  CAST(ip.ROUTES_ID+'-'+i.inv_entity AS VARCHAR(255)) AS ROUTES_ID ,
  ip.STARTING_ENTITY,
  i.entity,
  i.inv_entity,
  i.ratio ,
  ip.levels + 1 AS LEVELS
  FROM Invest1 i --持股事實表
  JOIN INVEST_ROUTE ip ON ip.inv_entity = i.entity
)
,T1 AS( --找路徑最大層
SELECT 
ROUTES_ID,
STARTING_ENTITY, 
entity, 
inv_entity, 
ratio, 
LEVELS,
MAX(LEVELS)OVER(PARTITION BY starting_entity,entity,inv_entity) AS MAX_LEVEL,
MAX(ROUTES_ID)OVER(PARTITION BY starting_entity,entity,inv_entity,LEVELS) AS MAX_ROUTE,
CASE WHEN MAX(LEVELS)OVER(PARTITION BY starting_entity,entity,inv_entity) != LEVELS THEN 'N'
    WHEN MAX(LEVELS)OVER(PARTITION BY starting_entity,entity,inv_entity) = LEVELS AND MAX(ROUTES_ID)OVER(PARTITION BY starting_entity,entity,inv_entity,LEVELS) != ROUTES_ID THEN 'N'
    ELSE 'Y' END AS KEEP --判斷數據是否要留
FROM INVEST_ROUTE
),T2 AS( --篩出保留路徑
SELECT
ROUTES_ID,
starting_entity, 
entity, 
inv_entity, 
ratio, 
levels,
MAX_LEVEL,
MAX(LEVELS)OVER(PARTITION BY STARTING_ENTITY,INV_ENTITY) AS MAX_INV_LEVEL
FROM T1
WHERE 1=1
AND KEEP = 'Y'
)
,T2_DEFER(ROUTES_ID,STARTING_ENTITY, entity, inv_entity, ratio, LEVELS, MAX_INV_LEVEL) AS( --遞迴二 層級遞延切齊
SELECT
ROUTES_ID,
STARTING_ENTITY, 
entity, 
inv_entity, 
ratio, 
LEVELS,
MAX_INV_LEVEL
FROM T2
UNION ALL 
SELECT
CAST(ROUTES_ID + '-' + INV_ENTITY AS VARCHAR(255)) AS ROUTES_ID,
STARTING_ENTITY, 
inv_entity AS entity, 
inv_entity, 
ratio, 
levels+1 AS LEVELS,
MAX_INV_LEVEL
FROM T2_DEFER
WHERE LEVELS+1 <= MAX_INV_LEVEL
)
,INV(ROUTES_ID,STARTING_ENTITY, entity, inv_entity, ratio,MULTIPLIER, ACC_RATIO, LEVELS,MAX_INV_LEVEL) AS( --遞迴三 逐層計算
SELECT 
ROUTES_ID,
STARTING_ENTITY, 
entity, 
inv_entity, 
CAST(ratio AS FLOAT) AS RATIO,
CASE WHEN ratio>=0.5 THEN 1
ELSE CAST(ratio AS FLOAT) END AS MULTIPLIER,
CAST(ratio AS FLOAT) AS ACC_RATIO,
LEVELS ,
MAX_INV_LEVEL
FROM T2_DEFER
WHERE LEVELS=1
UNION ALL
SELECT
T1.ROUTES_ID,
T1.STARTING_ENTITY, 
T1.entity, 
T1.inv_entity, 
CASE WHEN T1.entity=T1.inv_entity THEN CAST(t1.ratio AS FLOAT)
     WHEN T1.entity!=T1.inv_entity THEN CAST(t1.ratio*t2.MULTIPLIER AS FLOAT)
     END AS ratio,
CASE WHEN 
     (CASE WHEN t1.LEVELS = t1.MAX_INV_LEVEL THEN SUM(CASE WHEN T1.entity=T1.inv_entity THEN t1.ratio WHEN T1.entity!=T1.inv_entity THEN t1.ratio*t2.MULTIPLIER END)OVER(PARTITION BY T1.STARTING_ENTITY,T1.INV_ENTITY) 
     WHEN t1.LEVELS != t1.MAX_INV_LEVEL THEN t1.ratio END ) >=0.5 THEN 1
     ELSE (CASE WHEN t1.LEVELS = t1.MAX_INV_LEVEL THEN SUM(CASE WHEN T1.entity=T1.inv_entity THEN t1.ratio WHEN T1.entity!=T1.inv_entity THEN t1.ratio*t2.MULTIPLIER END)OVER(PARTITION BY T1.STARTING_ENTITY,T1.INV_ENTITY) 
     WHEN t1.LEVELS != t1.MAX_INV_LEVEL THEN CAST(t1.ratio AS FLOAT) END ) END AS MULTIPLIER,
CASE WHEN t1.LEVELS = t1.MAX_INV_LEVEL THEN SUM(CASE WHEN T1.entity=T1.inv_entity THEN t1.ratio WHEN T1.entity!=T1.inv_entity THEN t1.ratio*t2.MULTIPLIER END)OVER(PARTITION BY T1.STARTING_ENTITY,T1.INV_ENTITY) 
     WHEN t1.LEVELS != t1.MAX_INV_LEVEL THEN CAST(t1.ratio AS FLOAT) END AS ACC_RATIO,
T1.LEVELS ,
T1.MAX_INV_LEVEL
FROM T2_DEFER T1
JOIN INV T2 ON T1.LEVELS = T2.LEVELS+1 AND T1.STARTING_ENTITY = T2.STARTING_ENTITY AND T1.ENTITY = T2.INV_ENTITY AND T1.ROUTES_ID = T2.ROUTES_ID+'-'+T1.INV_ENTITY
)--SELECT * FROM INV
, ENTITY_DIRECT AS (
SELECT 
ENTITY_CODE AS ENTITY,
INV_ENTITY_CODE AS INV_ENTITY ,
RATIO_HOLD AS ratio 
FROM TRS_FACT_GROUP_INV_REL
WHERE 
	@P_DATE BETWEEN START_DATE AND END_DATE
	AND ENTITY_CODE = @PARA
), RES AS (
SELECT DISTINCT  t1.STARTING_ENTITY, t1.inv_entity, t1.ACC_RATIO, t2.ratio AS DIRECT_RATIO 
FROM INV t1
JOIN ENTITY_DIRECT t2 ON t1.STARTING_ENTITY = t2.entity AND t1.INV_ENTITY = t2.INV_ENTITY
WHERE LEVELS=MAX_INV_LEVEL
)
INSERT INTO TEMP_TRS_FACT_INV_CONTROL(ID, ENTITY_CODE, INV_ENTITY_CODE, RATIO_SUM, RATIO_DIRECT)
SELECT NEWID(), STARTING_ENTITY, INV_ENTITY, ACC_RATIO, ROUND(DIRECT_RATIO,4,1) FROM RES
OPTION (MAXRECURSION 3000)
END;

CREATE PROCEDURE P_CFC_ENTITY_VERSION
AS
BEGIN
		SELECT GETDATE() AS UPDATE_TIME;
	    TRUNCATE TABLE TRS_FACT_CFC_ENTITY_VERSION;
	    TRUNCATE TABLE TRS_FACT_CFC_ENTITY_VERSION_PERIOD_SCENARIO;
	    TRUNCATE TABLE TRS_FACT_CFC_ENTITY_VERSION_SCENARIO;
	    TRUNCATE TABLE TRS_FACT_CFC_ENTITY_VERSION_PERIOD;
    -- 清空 TRS_FACT_CFC_ENTITY_VERSION 表
       ;WITH CTE AS (
            SELECT DISTINCT
                EOMONTH(CONVERT(DATE, t1.PERIOD + RIGHT('0' + CAST(t1.MONTH AS VARCHAR(2)), 2) + '01')) AS PERIOD,
                t3.CURRENT_CODE AS ENTITY_CODE,
                t1.SCENARIO,
                MAX(t1.CREATED_TIME) OVER (PARTITION BY t1.PERIOD, t1.MONTH, t1.ENTITY_CODE, t1.SCENARIO) AS CREATED_TIME
            FROM TRS_FACT_TRIAL_BALANCE t1
            JOIN TRS_DIM_ENTITY t2 ON t1.ENTITY_CODE = t2.ENTITY_CODE AND t2.ENTITY_TYPE_ID = '003'
            LEFT JOIN V_TRS_DIM_ENTITY_CUR t3 ON t1.ENTITY_CODE = t3.ENTITY_CODE
        ),
        CTE2 AS (
            SELECT 
                PERIOD,
                ENTITY_CODE,
                SCENARIO,
                CREATED_TIME,
                RANK() OVER (PARTITION BY PERIOD, ENTITY_CODE, SCENARIO ORDER BY CREATED_TIME) AS RW
            FROM CTE
        ),CTE_RES AS (
        SELECT PERIOD, ENTITY_CODE, SCENARIO, CREATED_TIME
        FROM CTE2
        WHERE RW = 1)
    -- 使用 CTE 查詢並插入資料到 TRS_FACT_CFC_ENTITY_VERSION
    INSERT INTO TRS_FACT_CFC_ENTITY_VERSION (ID, PERIOD, ENTITY_CODE, SCENARIO, CREATED_TIME)
    SELECT NEWID(), PERIOD, ENTITY_CODE, SCENARIO, CREATED_TIME
    FROM CTE_RES;
    
    INSERT INTO TRS_FACT_CFC_ENTITY_VERSION_PERIOD_SCENARIO
    SELECT DISTINCT PERIOD, SCENARIO FROM TRS_FACT_CFC_ENTITY_VERSION;
    
    INSERT INTO TRS_FACT_CFC_ENTITY_VERSION_SCENARIO
    SELECT DISTINCT SCENARIO FROM TRS_FACT_CFC_ENTITY_VERSION;
   
    INSERT INTO TRS_FACT_CFC_ENTITY_VERSION_PERIOD
    SELECT DISTINCT PERIOD FROM TRS_FACT_CFC_ENTITY_VERSION;
   
   EXEC P_TRIGGER_TAX;
END;

CREATE PROCEDURE dbo.P_GENERATE_TB_MV
AS
BEGIN
	SELECT GETDATE() AS UPDATE_TIME;
	CREATE TABLE #temp_table (
        entity_code NVARCHAR(255),
        current_code NVARCHAR(255),
        entity_id VARCHAR(36),
        company_id VARCHAR(36),
        country_id VARCHAR(36),
        sales_function_id VARCHAR(36),
        period NVARCHAR(255),
        MONTH NVARCHAR(255),
        T1_CODE VARCHAR(255),
        T1_NAME NVARCHAR(255),
        T2_CODE VARCHAR(255),
        T2_NAME NVARCHAR(255),
        T2_DEBIT_CREDIT VARCHAR(36),
        T3_CODE VARCHAR(255),
        T3_NAME NVARCHAR(255),
        T3_DEBIT_CREDIT VARCHAR(36),
        T4_CODE VARCHAR(255),
        T4_NAME NVARCHAR(255),
        T4_DEBIT_CREDIT VARCHAR(36),
        T5_CODE VARCHAR(255),
        T5_NAME NVARCHAR(255),
        T5_DEBIT_CREDIT VARCHAR(36),
        T6_CODE VARCHAR(255),
        T6_NAME NVARCHAR(255),
        T6_DEBIT_CREDIT VARCHAR(36),
        T7_CODE VARCHAR(255),
        T7_NAME NVARCHAR(255),
        T7_DEBIT_CREDIT VARCHAR(36),
        ACCUMULATED_AMOUNT DECIMAL(24, 6),
        CURRENT_AMOUNT DECIMAL(24, 6),
        ACCUMULATED_AMOUNT_ORI DECIMAL(24, 6),
        CURRENT_AMOUNT_ORI DECIMAL(24, 6),
        CURRENCY_CODE VARCHAR(36),
        ifrs_version NVARCHAR(255),
        SCENARIO NVARCHAR(255),
        LANGUAGE VARCHAR(255),
        MV_UPDATED_TIME DATETIME,
        PERIOD_DATE DATE
    );

   WITH TABLE1 AS (
		SELECT 
		t1.entity_code,
		t1.period,
		t1.MONTH,
		T1_CODE,
		T1_NAME,
		T2_CODE,
		T2_NAME,
		T2_DEBIT_CREDIT,
		T3_CODE,
		T3_NAME,
		T3_DEBIT_CREDIT,
		T4_CODE,
		T4_NAME,
		T4_DEBIT_CREDIT,
		T5_CODE,
		T5_NAME,
		T5_DEBIT_CREDIT,
		T6_CODE,
		T6_NAME,
		T6_DEBIT_CREDIT,
		T7_CODE,
		T7_NAME,
		T7_DEBIT_CREDIT,
		t1.ACCUMULATED_AMOUNT ,
		t1.current_amount,
		t1.CURRENCY_CODE,
		t2.ifrs_version,
		t1.SCENARIO,
		LANGUAGE
		FROM TRS_FACT_TRIAL_BALANCE t1
		JOIN V_TRS_DIM_ACCOUNTING_RANKING t2 ON t1.account_code = t2.T7_CODE AND t1.IFRS_VERSION = t2.IFRS_VERSION 
		WHERE t1.VALUE_TYPE = 'actual'
		UNION ALL
		SELECT 
		t1.entity_code,
		t1.period,
		t1.MONTH,
		T1_CODE,
		T1_NAME,
		T2_CODE,
		T2_NAME,
		T2_DEBIT_CREDIT,
		T3_CODE,
		T3_NAME,
		T3_DEBIT_CREDIT,
		T4_CODE,
		T4_NAME,
		T4_DEBIT_CREDIT,
		T5_CODE,
		T5_NAME,
		T5_DEBIT_CREDIT,
		T6_CODE,
		T6_NAME,
		T6_DEBIT_CREDIT,
		ISNULL(T7_CODE,'-1') AS T7_CODE,
		T7_NAME,
		T7_DEBIT_CREDIT,
		t1.ACCUMULATED_AMOUNT ,
		t1.current_amount,
		t1.CURRENCY_CODE,
		t2.ifrs_version,
		t1.SCENARIO,
		LANGUAGE
		FROM TRS_FACT_TRIAL_BALANCE t1
		JOIN V_TRS_DIM_ACCOUNTING_RANKING t2 ON t1.account_code = t2.T6_CODE AND t1.IFRS_VERSION = t2.IFRS_VERSION 
		WHERE t1.VALUE_TYPE = 'actual'
		UNION ALL
		SELECT 
		t1.entity_code,
		t1.period,
		t1.MONTH,
		T1_CODE,
		T1_NAME,
		T2_CODE,
		T2_NAME,
		T2_DEBIT_CREDIT,
		T3_CODE,
		T3_NAME,
		T3_DEBIT_CREDIT,
		T4_CODE,
		T4_NAME,
		T4_DEBIT_CREDIT,
		T5_CODE,
		T5_NAME,
		T5_DEBIT_CREDIT,
		ISNULL(T6_CODE,'-1') AS T6_CODE,
		T6_NAME,
		T6_DEBIT_CREDIT,
		ISNULL(T7_CODE,'-1') AS T7_CODE,
		T7_NAME,
		T7_DEBIT_CREDIT,
		t1.ACCUMULATED_AMOUNT ,
		t1.current_amount,
		t1.CURRENCY_CODE,
		t2.ifrs_version,
		t1.SCENARIO,
		LANGUAGE
		FROM TRS_FACT_TRIAL_BALANCE t1
		JOIN V_TRS_DIM_ACCOUNTING_RANKING t2 ON t1.account_code = t2.T5_CODE AND t1.IFRS_VERSION = t2.IFRS_VERSION 
		WHERE t1.VALUE_TYPE = 'actual'
		UNION ALL
		SELECT 
		t1.entity_code,
		t1.period,
		t1.MONTH,
		T1_CODE,
		T1_NAME,
		T2_CODE,
		T2_NAME,
		T2_DEBIT_CREDIT,
		T3_CODE,
		T3_NAME,
		T3_DEBIT_CREDIT,
		T4_CODE,
		T4_NAME,
		T4_DEBIT_CREDIT,
		ISNULL(T5_CODE,'-1') AS T5_CODE,
		T5_NAME,
		T5_DEBIT_CREDIT,
		ISNULL(T6_CODE,'-1') AS T6_CODE,
		T6_NAME,
		T6_DEBIT_CREDIT,
		ISNULL(T7_CODE,'-1') AS T7_CODE,
		T7_NAME,
		T7_DEBIT_CREDIT,
		t1.ACCUMULATED_AMOUNT ,
		t1.current_amount,
		t1.CURRENCY_CODE,
		t2.ifrs_version,
		t1.SCENARIO,
		LANGUAGE
		FROM TRS_FACT_TRIAL_BALANCE t1
		JOIN V_TRS_DIM_ACCOUNTING_RANKING t2 ON t1.account_code = t2.T4_CODE AND t1.IFRS_VERSION = t2.IFRS_VERSION 
		WHERE t1.VALUE_TYPE = 'actual'
		UNION ALL
		SELECT 
		t1.entity_code,
		t1.period,
		t1.MONTH,
		T1_CODE,
		T1_NAME,
		T2_CODE,
		T2_NAME,
		T2_DEBIT_CREDIT,
		T3_CODE,
		T3_NAME,
		T3_DEBIT_CREDIT,
		ISNULL(T4_CODE,'-1') AS T4_CODE,
		T4_NAME,
		T4_DEBIT_CREDIT,
		ISNULL(T5_CODE,'-1') AS T5_CODE,
		T5_NAME,
		T5_DEBIT_CREDIT,
		ISNULL(T6_CODE,'-1') AS T6_CODE,
		T6_NAME,
		T6_DEBIT_CREDIT,
		ISNULL(T7_CODE,'-1') AS T7_CODE,
		T7_NAME,
		T7_DEBIT_CREDIT,
		t1.ACCUMULATED_AMOUNT ,
		t1.current_amount,
		t1.CURRENCY_CODE,
		t2.ifrs_version,
		t1.SCENARIO,
		LANGUAGE
		FROM TRS_FACT_TRIAL_BALANCE t1
		JOIN V_TRS_DIM_ACCOUNTING_RANKING t2 ON t1.account_code = t2.T3_CODE AND t1.IFRS_VERSION = t2.IFRS_VERSION 
		WHERE t1.VALUE_TYPE = 'actual'
		UNION ALL
		SELECT 
		t1.entity_code,
		t1.period,
		t1.MONTH,
		T1_CODE,
		T1_NAME,
		T2_CODE,
		T2_NAME,
		T2_DEBIT_CREDIT,
		ISNULL(T3_CODE,'-1') AS T3_CODE,
		T3_NAME,
		T3_DEBIT_CREDIT,
		ISNULL(T4_CODE,'-1') AS T4_CODE,
		T4_NAME,
		T4_DEBIT_CREDIT,
		ISNULL(T5_CODE,'-1') AS T5_CODE,
		T5_NAME,
		T5_DEBIT_CREDIT,
		ISNULL(T6_CODE,'-1') AS T6_CODE,
		T6_NAME,
		T6_DEBIT_CREDIT,
		ISNULL(T7_CODE,'-1') AS T7_CODE,
		T7_NAME,
		T7_DEBIT_CREDIT,
		t1.ACCUMULATED_AMOUNT ,
		t1.current_amount,
		t1.CURRENCY_CODE,
		t2.ifrs_version,
		t1.SCENARIO,
		LANGUAGE
		FROM TRS_FACT_TRIAL_BALANCE t1
		JOIN V_TRS_DIM_ACCOUNTING_RANKING t2 ON t1.account_code = t2.T2_CODE AND t1.IFRS_VERSION = t2.IFRS_VERSION 
		WHERE t1.VALUE_TYPE = 'actual'
		UNION ALL
		SELECT 
		t1.entity_code,
		t1.period,
		t1.MONTH,
		T1_CODE,
		T1_NAME,
		ISNULL(T2_CODE,'-1') AS T2_CODE,
		T2_NAME,
		T2_DEBIT_CREDIT,
		ISNULL(T3_CODE,'-1') AS T3_CODE,
		T3_NAME,
		T3_DEBIT_CREDIT,
		ISNULL(T4_CODE,'-1') AS T4_CODE,
		T4_NAME,
		T4_DEBIT_CREDIT,
		ISNULL(T5_CODE,'-1') AS T5_CODE,
		T5_NAME,
		T5_DEBIT_CREDIT,
		ISNULL(T6_CODE,'-1') AS T6_CODE,
		T6_NAME,
		T6_DEBIT_CREDIT,
		ISNULL(T7_CODE,'-1') AS T7_CODE,
		T7_NAME,
		T7_DEBIT_CREDIT,
		t1.ACCUMULATED_AMOUNT ,
		t1.current_amount,
		t1.CURRENCY_CODE,
		t2.ifrs_version,
		t1.SCENARIO,
		LANGUAGE
		FROM TRS_FACT_TRIAL_BALANCE t1
		JOIN V_TRS_DIM_ACCOUNTING_RANKING t2 ON t1.account_code = t2.T1_CODE AND t1.IFRS_VERSION = t2.IFRS_VERSION 
		WHERE t1.VALUE_TYPE = 'actual'
		)
		
		INSERT INTO #temp_table (
    entity_code,
    current_code,
    entity_id,
    company_id,
    country_id,
    sales_function_id,
    period,
    MONTH,
    T1_CODE,
    T1_NAME,
    T2_CODE,
    T2_NAME,
    T2_DEBIT_CREDIT,
    T3_CODE,
    T3_NAME,
    T3_DEBIT_CREDIT,
    T4_CODE,
    T4_NAME,
    T4_DEBIT_CREDIT,
    T5_CODE,
    T5_NAME,
    T5_DEBIT_CREDIT,
    T6_CODE,
    T6_NAME,
    T6_DEBIT_CREDIT,
    T7_CODE,
    T7_NAME,
    T7_DEBIT_CREDIT,
    ACCUMULATED_AMOUNT,
    CURRENT_AMOUNT,
    ACCUMULATED_AMOUNT_ORI,
    CURRENT_AMOUNT_ORI,
    CURRENCY_CODE,
    ifrs_version,
    SCENARIO,
    LANGUAGE,
    MV_UPDATED_TIME,
    PERIOD_DATE
)
		SELECT 
		t1.entity_code,
		t3.current_code,
		t2.entity_id,
		t2.company_id,
		t2.country_id,
		t2.sales_function_id,
		t1.period,
		CASE WHEN LEN(t1.MONTH)=1 THEN CONCAT(0,t1.MONTH) ELSE MONTH END AS MONTH,
		T1_CODE,
		T1_NAME,
		T2_CODE,
		T2_NAME,
		T2_DEBIT_CREDIT,
		T3_CODE,
		T3_NAME,
		T3_DEBIT_CREDIT,
		T4_CODE,
		T4_NAME,
		T4_DEBIT_CREDIT,
		T5_CODE,
		T5_NAME,
		T5_DEBIT_CREDIT,
		T6_CODE,
		T6_NAME,
		T6_DEBIT_CREDIT,
		T7_CODE,
		T7_NAME,
		T7_DEBIT_CREDIT,
		CASE WHEN t1.T2_DEBIT_CREDIT ='C' THEN t1.ACCUMULATED_AMOUNT*(-1) 
		  WHEN t1.T2_DEBIT_CREDIT !='C' THEN t1.ACCUMULATED_AMOUNT
		  END AS ACCUMULATED_AMOUNT,
		CASE WHEN t1.T2_DEBIT_CREDIT ='C' THEN t1.current_amount*(-1) 
		  WHEN t1.T2_DEBIT_CREDIT !='C' THEN t1.current_amount
		  END AS CURRENT_AMOUNT,
		t1.ACCUMULATED_AMOUNT AS ACCUMULATED_AMOUNT_ORI,
		t1.CURRENT_AMOUNT AS CURRENT_AMOUNT_ORI,
		t1.CURRENCY_CODE,
		t1.ifrs_version,
		t1.SCENARIO,
		t1.LANGUAGE,
		GETDATE() AS MV_UPDATED_TIME,
		DATEADD(DAY,-1,DATEADD(MONTH,1,CAST(PERIOD+'-'+MONTH+'-01' AS DATE))) AS PERIOD_DATE
		FROM TABLE1 t1
		LEFT JOIN V_TRS_DIM_ENTITY t2 ON t1.ENTITY_CODE =t2.entity_code AND t1.LANGUAGE = t2.LANGUAGE
		LEFT JOIN V_TRS_DIM_ENTITY_CUR t3 ON t1.ENTITY_CODE = T3.ENTITY_CODE;

	TRUNCATE TABLE MV_TRS_TB_ACTUAL_ACCOUNT_AMOUNT;
	INSERT INTO MV_TRS_TB_ACTUAL_ACCOUNT_AMOUNT(
    entity_code,
    current_code,
    entity_id,
    company_id,
    country_id,
    sales_function_id,
    period,
    MONTH,
    T1_CODE,
    T1_NAME,
    T2_CODE,
    T2_NAME,
    T2_DEBIT_CREDIT,
    T3_CODE,
    T3_NAME,
    T3_DEBIT_CREDIT,
    T4_CODE,
    T4_NAME,
    T4_DEBIT_CREDIT,
    T5_CODE,
    T5_NAME,
    T5_DEBIT_CREDIT,
    T6_CODE,
    T6_NAME,
    T6_DEBIT_CREDIT,
 T7_CODE,
    T7_NAME,
    T7_DEBIT_CREDIT,
    ACCUMULATED_AMOUNT,
    CURRENT_AMOUNT,
    ACCUMULATED_AMOUNT_ORI,
    CURRENT_AMOUNT_ORI,
    CURRENCY_CODE,
    ifrs_version,
    SCENARIO,
    LANGUAGE,
    MV_UPDATED_TIME,
    PERIOD_DATE
)
	SELECT * FROM #temp_table;
DROP TABLE #temp_table;

END;

CREATE PROCEDURE P_GET_RATIO_HOLD
	@ID VARCHAR(50),
	@P_DATE DATE,
	@P_COMPANY VARCHAR(255),
	@P_CFC VARCHAR(255)
AS
BEGIN
WITH CTE AS (
	SELECT
		ENTITY_CODE,
		 INV_ENTITY_CODE,
		CAST(RATIO_HOLD AS FLOAT) AS RATIO_HOLD
	FROM TRS_FACT_GROUP_INV_REL 
	WHERE @P_DATE BETWEEN START_DATE AND END_DATE
)
, stock_ratio (base_entity, inv_entity, ratio, depth) AS (
  --初始化所有基本關係
  SELECT ENTITY_CODE, INV_ENTITY_CODE, RATIO_HOLD, 1
  FROM CTE
  UNION ALL
  -- 遞歸擴展關係
  SELECT t1.base_entity, t2.INV_ENTITY_CODE, t1.ratio * t2.RATIO_HOLD,
         t1.depth + 1
  FROM stock_ratio t1
  JOIN CTE t2 ON t1.inv_entity = t2.ENTITY_CODE
  WHERE t1.depth < 20 -- 限制遞歸深度以防止無限循環
)
,CTE2 AS (
SELECT * FROM stock_ratio
--ORDER BY base_entity, depth, path
),CTE_RES AS (
SELECT
	BASE_ENTITY,
	INV_ENTITY,
	ROUND(SUM(RATIO), 4, 1) AS RATIO
FROM CTE2
WHERE	 
	BASE_ENTITY = @P_COMPANY
	AND INV_ENTITY = @P_CFC
GROUP BY BASE_ENTITY, INV_ENTITY
--ORDER BY BASE_ENTITY
)
UPDATE TRS_FACT_CFC_INV_DIVIDEND SET RATIO_HOLD = (SELECT RATIO FROM CTE_RES)
WHERE ID = @ID
/*CFC_INV_ENTITY_CODE = @P_CFC
	AND CFC_ENTITY_CODE = @P_COMPANY
	AND DECLARATION_DATE = @P_DATE*/
;
END;

CREATE PROCEDURE P_GET_RATIO_HOLD_NONLOWTAX_ADJ_1
	@ID VARCHAR(50),
	@P_DATE DATE,
	@P_COMPANY VARCHAR(255),
	@P_CFC VARCHAR(255)
AS
BEGIN
WITH CTE AS (
	SELECT
		ENTITY_CODE,
		INV_ENTITY_CODE,
		CAST(RATIO_HOLD AS FLOAT) AS RATIO_HOLD
	FROM TRS_FACT_GROUP_INV_REL
	WHERE @P_DATE BETWEEN START_DATE AND END_DATE
)
, stock_ratio (base_entity, inv_entity, ratio, depth) AS (
  --初始化所有基本關係
  SELECT ENTITY_CODE, INV_ENTITY_CODE, RATIO_HOLD, 1
  FROM CTE
  UNION ALL
  -- 遞歸擴展關係
  SELECT t1.base_entity, t2.INV_ENTITY_CODE, t1.ratio * t2.RATIO_HOLD,
         t1.depth + 1
  FROM stock_ratio t1
  JOIN CTE t2 ON t1.inv_entity = t2.ENTITY_CODE
  WHERE t1.depth < 20 -- 限制遞歸深度以防止無限循環
)
,CTE2 AS (
SELECT * FROM stock_ratio
--ORDER BY base_entity, depth, path
),CTE_RES AS (
SELECT
	BASE_ENTITY,
	INV_ENTITY,
	ROUND(SUM(RATIO), 4, 1) AS RATIO
FROM CTE2
WHERE	 
	BASE_ENTITY = @P_COMPANY
	AND INV_ENTITY = @P_CFC
GROUP BY BASE_ENTITY, INV_ENTITY
--ORDER BY BASE_ENTITY
)
UPDATE TRS_FACT_CFC_NONLOW_ADJ SET RATIO_HOLD = CASE WHEN CFC_ENTITY_CODE = SELL_COMPANY THEN 1 ELSE (SELECT RATIO FROM CTE_RES) END
WHERE ID = @ID
/*INV_ENTITY_CODE = @P_CFC
	AND CFC_ENTITY_CODE = @P_COMPANY
	AND DISPOSE_DATE = @P_DATE*/
END;

CREATE PROCEDURE P_GET_RATIO_HOLD_NONLOWTAX_ADJ_2
	@ID VARCHAR(50),
	@P_DATE DATE,
	@P_COMPANY VARCHAR(255),
	@P_CFC VARCHAR(255)
AS
BEGIN
WITH CTE AS (
	SELECT
		ENTITY_CODE,
		INV_ENTITY_CODE,
		CAST(RATIO_HOLD AS FLOAT) AS RATIO_HOLD
	FROM TRS_FACT_GROUP_INV_REL
	WHERE @P_DATE BETWEEN START_DATE AND END_DATE
)
, stock_ratio (base_entity, inv_entity, ratio, depth) AS (
  --初始化所有基本關係
  SELECT ENTITY_CODE, INV_ENTITY_CODE, RATIO_HOLD, 1
  FROM CTE
  UNION ALL
  -- 遞歸擴展關係
  SELECT t1.base_entity, t2.INV_ENTITY_CODE, t1.ratio * t2.RATIO_HOLD,
         t1.depth + 1
  FROM stock_ratio t1
  JOIN CTE t2 ON t1.inv_entity = t2.ENTITY_CODE
  WHERE t1.depth < 20 -- 限制遞歸深度以防止無限循環
)
,CTE2 AS (
SELECT * FROM stock_ratio
--ORDER BY base_entity, depth, path
),CTE_RES AS (
SELECT
	BASE_ENTITY,
	INV_ENTITY,
	ROUND(SUM(RATIO), 4, 1) AS RATIO
FROM CTE2
WHERE	 
	BASE_ENTITY = @P_COMPANY
	AND INV_ENTITY = @P_CFC
GROUP BY BASE_ENTITY, INV_ENTITY
--ORDER BY BASE_ENTITY
)
UPDATE TRS_FACT_CFC_NONLOW_ADJ SET SELL_RATIO_HOLD = CASE WHEN CFC_ENTITY_CODE = SELL_COMPANY THEN 1 ELSE (SELECT RATIO FROM CTE_RES) END
WHERE ID = @ID
/*WHERE SELL_COMPANY = @P_CFC
	AND CFC_ENTITY_CODE = @P_COMPANY
	AND DISPOSE_DATE = @P_DATE*/
END;

CREATE PROCEDURE P_GET_RATIO_HOLD_REALIZED_LOSS
	@ID VARCHAR(50),
	@P_DATE DATE,
	@P_COMPANY VARCHAR(255),
	@P_CFC VARCHAR(255)
AS
BEGIN
WITH CTE AS (
	SELECT
		ENTITY_CODE,
		INV_ENTITY_CODE,
		CAST(RATIO_HOLD AS FLOAT) AS RATIO_HOLD
	FROM TRS_FACT_GROUP_INV_REL
	WHERE @P_DATE BETWEEN START_DATE AND END_DATE
)
, stock_ratio (base_entity, inv_entity, ratio, depth) AS (
  --初始化所有基本關係
  SELECT ENTITY_CODE, INV_ENTITY_CODE, RATIO_HOLD, 1
  FROM CTE
  UNION ALL
  -- 遞歸擴展關係
  SELECT t1.base_entity, t2.INV_ENTITY_CODE, t1.ratio * t2.RATIO_HOLD,
         t1.depth + 1
  FROM stock_ratio t1
  JOIN CTE t2 ON t1.inv_entity = t2.ENTITY_CODE
  WHERE t1.depth < 20 -- 限制遞歸深度以防止無限循環
)
,CTE2 AS (
SELECT * FROM stock_ratio
--ORDER BY base_entity, depth, path
),CTE_RES AS (
SELECT
	BASE_ENTITY,
	INV_ENTITY,
	ROUND(SUM(RATIO), 4, 1) AS RATIO
FROM CTE2
WHERE	 
	BASE_ENTITY = @P_COMPANY
	AND INV_ENTITY = @P_CFC
GROUP BY BASE_ENTITY, INV_ENTITY
--ORDER BY BASE_ENTITY
)
UPDATE TRS_FACT_CFC_REALIZED_LOSS SET RATIO_HOLD = CASE WHEN @P_CFC=@P_COMPANY THEN 1 ELSE (SELECT RATIO FROM CTE_RES) END
WHERE ID = @ID
/*INV_ENTITY_CODE = @P_CFC
	AND CFC_ENTITY_CODE = @P_COMPANY
	AND LOSS_DATE = @P_DATE;*/
;
END;

CREATE PROCEDURE P_INV_CONTROL_LOOP_DATE
AS
BEGIN
	SELECT GETDATE() AS UPDATE_TIME;
    DECLARE @P_DATE DATE = EOMONTH('2022-01-01'); -- 設定起始日
    DECLARE @P_DATE_DIF INT = DATEDIFF(MONTH, EOMONTH('2022-01-01'), GETDATE()); 
    -- 計算起始日與目前日期的月份差

    -- 清空目標表
    	CREATE TABLE TEMP_TRS_FACT_INV_CONTROL(
	ID varchar(36) COLLATE Chinese_Taiwan_Stroke_CI_AS NOT NULL,
	PERIOD date NULL,
	ENTITY_CODE nvarchar(255) COLLATE Chinese_Taiwan_Stroke_CI_AS NULL,
	INV_ENTITY_CODE nvarchar(255) COLLATE Chinese_Taiwan_Stroke_CI_AS NULL,
	UPDATED_TIME datetime NULL,
	RATIO_SUM decimal(24,5) NULL,
	RATIO_DIRECT decimal(24,5) NULL,
	RATIO_INDIRECT decimal(24,5) NULL,
);
	
	
    DECLARE @i INT = 1;
    WHILE @i <= @P_DATE_DIF + 48
    BEGIN
        -- 查詢符合日期範圍的 ENTITY_CODE
        DECLARE CUR CURSOR FOR
        SELECT DISTINCT ENTITY_CODE 
        FROM TRS_FACT_GROUP_INV_REL
        WHERE START_DATE <= @P_DATE AND END_DATE >= @P_DATE
        ORDER BY ENTITY_CODE;

        OPEN CUR;
        DECLARE @ENTITY_CODE VARCHAR(255);

        FETCH NEXT FROM CUR INTO @ENTITY_CODE;
        WHILE @@FETCH_STATUS = 0
        BEGIN
            -- 執行計算控制力的存儲程序
            EXEC P_CALCULATE_INV_CONTROL @ENTITY_CODE, @P_DATE;
            FETCH NEXT FROM CUR INTO @ENTITY_CODE;
        END;
        CLOSE CUR;
        DEALLOCATE CUR;

        -- 更新 TRS_FACT_INV_CONTROL 表的 PERIOD 欄位為 P_DATE
        UPDATE TEMP_TRS_FACT_INV_CONTROL
        SET PERIOD = @P_DATE
        WHERE PERIOD IS NULL;

        -- 計算下一個月的最後一天
        SET @P_DATE = EOMONTH(DATEADD(MONTH, 1, @P_DATE));
        SET @i = @i + 1;
    END;

    -- 計算間接持股比率，更新最後編輯時間
    UPDATE TEMP_TRS_FACT_INV_CONTROL
    SET RATIO_INDIRECT = RATIO_SUM - RATIO_DIRECT,
        UPDATED_TIME = GETDATE();
  TRUNCATE TABLE TRS_FACT_INV_CONTROL;
  INSERT INTO TRS_FACT_INV_CONTROL(ID,PERIOD, ENTITY_CODE, INV_ENTITY_CODE,UPDATED_TIME, RATIO_SUM, RATIO_DIRECT,RATIO_INDIRECT)
  SELECT * FROM TEMP_TRS_FACT_INV_CONTROL;
  DROP TABLE TEMP_TRS_FACT_INV_CONTROL;
END;

CREATE PROCEDURE P_INV_DETAIL AS 
BEGIN
	SELECT GETDATE() AS UPDATE_TIME;
TRUNCATE TABLE TRS_FACT_INV_DETAIL;
WITH CTE_QTY AS (
SELECT 
	ROW_NUMBER()OVER (PARTITION BY t2.CURRENT_CODE,t3.CURRENT_CODE ORDER BY T1.START_DATE) AS ORD,
   t2.CURRENT_CODE AS ENTITY_CODE,
    t3.CURRENT_CODE AS INV_ENTITY_CODE,
    t1.START_DATE,
    t1.SHARES_HOLD,
    INV_ADJITEM_CODE
FROM PRE_TRS_FACT_GROUP_INV_REL t1
JOIN V_TRS_DIM_ENTITY_CUR t2 ON t1.ENTITY_CODE = t2.ENTITY_CODE
JOIN V_TRS_DIM_ENTITY_CUR t3 ON t1.INV_ENTITY_CODE = t3.ENTITY_CODE
)
INSERT INTO TRS_FACT_INV_DETAIL
SELECT
	t1.ENTITY_CODE,
	t1.INV_ENTITY_CODE,
	t1.START_DATE,
	--t1.SHARES_HOLD,
	t1.INV_ADJITEM_CODE,
	/*t1.SHARES_HOLD,
	t2.SHARES_HOLD,*/
	ISNULL(t1.SHARES_HOLD,0)-ISNULL(t2.SHARES_HOLD,0) AS SHARE_QTY,
	CASE WHEN ISNULL(t1.SHARES_HOLD,0)-ISNULL(t2.SHARES_HOLD,0) >= 0 THEN 'add' ELSE 'less' END AS ADD_LESS,
	GETDATE() AS UPDATED_TIME
FROM CTE_QTY t1
LEFT JOIN CTE_QTY t2 ON t1.ORD-1 = t2.ORD AND t1.ENTITY_CODE = t2.ENTITY_CODE AND t1.INV_ENTITY_CODE = t2.INV_ENTITY_CODE;
TRUNCATE TABLE TRS_DIM_INV_SECURITY;
INSERT INTO TRS_DIM_INV_SECURITY
SELECT DISTINCT 
	INV_ENTITY_CODE AS INV_SECURITY_ID, 
	INV_ENTITY_CODE AS INV_SECURITY_CODE, 
	INV_ENTITY_CODE AS CORR_COMPANY_ID
FROM PRE_TRS_FACT_GROUP_INV_REL;
END;

CREATE PROCEDURE  P_TEMP_TRS_10Y_DEDUCTION_DETAIL AS
BEGIN
	SELECT GETDATE() AS UPDATE_TIME;
TRUNCATE TABLE TEMP_TRS_10Y_DEDUCTION_DETAIL;
;WITH CTE AS(
SELECT 
	PERIOD,
	YYYY,
	SCENARIO,
	ENTITY_CODE,
	CFC_ENTITY_CODE,
	EARNINGS_TAX,
	LOSS_TAX,
	EARNINGS_ASSESSMENT,
	LOSS_ASSESSMENT,
	APPROVAL
FROM V_TRS_FACT_CFC_10Y_LOSS_DEDUCTED
),CTE_VERSION AS (
SELECT DISTINCT 
	SCENARIO
FROM TRS_FACT_CFC_ENTITY_VERSION
)
,CTE_REC_LOSS AS (
SELECT
	t1.CFC_ENTITY_CODE,
	t2.SCENARIO,
	t1.DECLARE_DATE,
	t1.REC_YEAR,
	t1.AMOUNT
FROM V_TRS_FACT_CFC_RECOGNIZED_LOSS t1
CROSS JOIN CTE_VERSION t2
WHERE t1.SCENARIO = 'Per Audit' AND t1."TYPE" = 'CAP_RED' AND t1.REC_YEAR >= '2023' AND t1.DECLARE_DATE < DATEFROMPARTS(YEAR(GETDATE()), 1, 1)
UNION ALL
SELECT 	
	t1.CFC_ENTITY_CODE,
	cast(t1.SCENARIO as nvarchar),
	t1.DECLARE_DATE,
	t1.REC_YEAR,
	t1.AMOUNT
FROM V_TRS_FACT_CFC_RECOGNIZED_LOSS t1
WHERE t1.DECLARE_DATE >= DATEFROMPARTS(YEAR(GETDATE()), 1, 1) AND t1."TYPE" = 'CAP_RED' AND t1.REC_YEAR >= '2023'
)
,CTE1 AS (
SELECT 
	t1.PERIOD,
	t1.ENTITY_CODE,
	t1.CFC_ENTITY_CODE,
	t1.SCENARIO ,
	t1.YYYY,
	(CASE WHEN (APPROVAL IS NULL OR APPROVAL = 'false' )AND EARNINGS_TAX IS NULL THEN LOSS_TAX * -1
	WHEN (APPROVAL IS NULL OR APPROVAL = 'false' ) AND EARNINGS_TAX IS NOT NULL THEN EARNINGS_TAX
	WHEN APPROVAL = 'true' AND EARNINGS_ASSESSMENT IS NULL THEN LOSS_ASSESSMENT * -1
	ELSE EARNINGS_ASSESSMENT END) AS AMT,
	'0' AS CATEGORY
	FROM CTE t1
UNION ALL
SELECT 
	DISTINCT 
	t1.PERIOD,
	t1.ENTITY_CODE,
	t1.CFC_ENTITY_CODE,
	t1.SCENARIO,
	t2.DECLARE_DATE,
	t2.AMOUNT,
	'1' AS CATEGORY
FROM CTE t1
JOIN CTE_REC_LOSS t2 ON t2.DECLARE_DATE BETWEEN DATEFROMPARTS(YEAR(DATEADD(MONTH, -120, t1.PERIOD)), 1, 1) AND t1.PERIOD
AND t1.CFC_ENTITY_CODE = t2.CFC_ENTITY_CODE AND t1.SCENARIO = t2.SCENARIO
)
,CTE2 AS (
SELECT 
	ROW_NUMBER() OVER(PARTITION BY PERIOD, SCENARIO, ENTITY_CODE, CFC_ENTITY_CODE ORDER BY YYYY) AS ID,
	PERIOD,
	ENTITY_CODE,
	CFC_ENTITY_CODE,
	SCENARIO,
	YYYY,
	AMT,
	CATEGORY
FROM CTE1
) INSERT INTO TEMP_TRS_10Y_DEDUCTION_DETAIL SELECT *,GETDATE() AS UPDATED_TIME FROM CTE2
END;

CREATE PROCEDURE P_TEMP_TRS_FACT_CFC_INV_INCOME1 AS 
BEGIN 
	SELECT GETDATE() AS UPDATE_TIME;
	TRUNCATE TABLE TEMP_TRS_FACT_CFC_INV_INCOME1;
  ;WITH CTE_VERSION AS (
SELECT DISTINCT
	SCENARIO
FROM TRS_FACT_CFC_ENTITY_VERSION_SCENARIO
),CTE_HEAD AS (
SELECT DISTINCT
	PERIOD,
	SCENARIO,
	ENTITY_CODE
FROM V_TRS_FACT_CFC_ENTITY_VERSION
),CTE_PERIOD AS (
SELECT DISTINCT
	PERIOD
FROM TRS_FACT_CFC_ENTITY_VERSION_PERIOD
), CTE_THIS_YEAR AS(
SELECT
	SUM(DEDUCTION) AS DEDUCTION,
	SCENARIO,
	ENTITY_CODE,
	CFC_ENTITY_CODE,
	PERIOD,
	FISCAL_YEAR
FROM V_TRS_CFC_10Y_DEDUCTION_DETAIL
WHERE YEAR(PERIOD) = YEAR(DEDUCTED_YEAR)
GROUP BY PERIOD, SCENARIO, ENTITY_CODE, CFC_ENTITY_CODE, FISCAL_YEAR
)
,PROFIT000 AS (
SELECT
	t1.PERIOD,
	t1.SCENARIO,
	t1.ENTITY_CODE,
	t1.INV_ENTITY_CODE AS CFC_ENTITY_CODE,
	CASE WHEN t3.APPROVAL = 'true' AND t2.GAIN_LOSS = 'EARN' THEN t2.AMOUNT
	WHEN t3.APPROVAL = 'true' AND t2.GAIN_LOSS = 'LOSS' THEN t2.AMOUNT * -1
	ELSE t1.CFC_EARNINGS END AS CFC_EARNINGS,
	'PROFIT' AS DATA_TYPE,
	t1.AVG_RATIO_HOLD,
	CASE WHEN SUM(t1.CFC_EARNINGS) OVER(PARTITION BY t1.PERIOD, t1.SCENARIO, t1.ENTITY_CODE) >= 7000000 AND CFC_EARNINGS >= 0 THEN 'true'
	WHEN CFC_EARNINGS >= 7000000 THEN 'true' 
	WHEN ( CASE WHEN DATEDIFF(MONTH, t4.START_DATE,t1.PERIOD) + 1 < 12 AND DATEFROMPARTS(YEAR(GETDATE()), 1, 1) > t4.START_DATE THEN CFC_EARNINGS * 12 / DATEDIFF(MONTH,DATEFROMPARTS(YEAR(GETDATE()), 1, 1),t1.PERIOD) +1 
	ELSE CFC_EARNINGS * 12 / DATEDIFF(MONTH, t4.START_DATE, t1.PERIOD) + 1 END) > 7000000 THEN 'true' --小於一年判斷是否從今年初計算全年
	ELSE 'false' END AS IS_TAX
FROM V_TRS_FACT_CFC_TAX_INCOME t1
LEFT JOIN V_TRS_FACT_CFC_APPROVAL_DETAIL t2 ON YEAR(t1.PERIOD) = t2.YEAR AND t1.SCENARIO = t2.SCENARIO AND t1.ENTITY_CODE = t2.ENTITY_CODE AND t1.INV_ENTITY_CODE = t2.INV_ENTITY_CODE
LEFT JOIN V_TRS_FACT_CFC_APPROVAL t3 ON t1.PERIOD = (t3.YEAR + '-12-31') AND t1.ENTITY_CODE = t3.ENTITY_CODE AND t1.SCENARIO = t3.SCENARIO
LEFT JOIN TRS_DIM_COMPANY t4 ON t1.INV_ENTITY_CODE = t4.COMPANY_CODE AND t4.START_DATE < t1.PERIOD
WHERE CFC_EARNINGS > 0 AND SUB_OPE_EXEMPTION = 'false' --非實質營運才參與計算
),PROFIT00 AS (
SELECT
	t1.PERIOD,
	t1.SCENARIO,
	t1.ENTITY_CODE,
	t1.CFC_ENTITY_CODE,
	t1.CFC_EARNINGS,
	t1.DATA_TYPE,
	t1.AVG_RATIO_HOLD
FROM PROFIT000 t1
WHERE IS_TAX = 'true'
), CTE_LIMIT AS (
--	自”限制分配狀況”頁面取數，加總金額；若該CFC為實質營運，則顯示空白
	SELECT
		t1.PERIOD,
		t1.SCENARIO,
		t1.ENTITY_CODE AS CFC_ENTITY_CODE,
		ISNULL(SUM(t1.AMOUNT), 0) AS LIMIT_ITEMS
	FROM V_TRS_FACT_CFC_RESTRICTED_DISTRIBUTION t1
	WHERE 1 = 1
		AND ITEM != 'SPECIAL_RESERVE_NREGU'
		AND YEAR(t1.PERIOD) = t1.ORIGIN_YEAR
	GROUP BY t1.PERIOD, t1.SCENARIO, t1.ENTITY_CODE
)
,PROFIT0 AS (
SELECT
	t1.PERIOD,
	t1.SCENARIO,
	t1.ENTITY_CODE,
	t1.CFC_ENTITY_CODE,
	t1.DATA_TYPE,
	(t1.CFC_EARNINGS - ISNULL(t4.DEDUCTION, 0) - ISNULL(t2.LIMIT_ITEMS, 0)) * t1.AVG_RATIO_HOLD AS CFC_EARNINGS 
FROM PROFIT00 t1
LEFT JOIN CTE_THIS_YEAR t4 ON t1.PERIOD = t4.PERIOD AND t1.SCENARIO = t4.SCENARIO AND t1.ENTITY_CODE = t4.ENTITY_CODE AND t1.CFC_ENTITY_CODE = t4.CFC_ENTITY_CODE
LEFT JOIN CTE_LIMIT T2 ON T1.SCENARIO = T2.SCENARIO AND T1.CFC_ENTITY_CODE = T2.CFC_ENTITY_CODE AND T1.PERIOD = T2.PERIOD
)
,CTE_PA AS (
SELECT
	t1.PERIOD,
	t2.SCENARIO,
	t1.ENTITY_CODE,
	t1.CFC_ENTITY_CODE,
	t1.CFC_EARNINGS,
	t1.DATA_TYPE
FROM PROFIT0 t1
CROSS JOIN CTE_VERSION t2
WHERE t1.SCENARIO = 'Per Audit' AND FORMAT(t1.PERIOD, 'MM-dd') = '12-31'
),PROFIT AS (
SELECT
	t1.PERIOD,
	t2.PERIOD AS PERIOD1,
	t2.SCENARIO,
	t1.ENTITY_CODE,
	t2.CFC_ENTITY_CODE,
	t2.CFC_EARNINGS,
	t2.DATA_TYPE
FROM CTE_HEAD t1
JOIN CTE_PA t2 ON t1.PERIOD > t2.PERIOD AND t1.SCENARIO = t2.SCENARIO AND t1.ENTITY_CODE = t2.ENTITY_CODE
--WHERE ROWNUM <= 1000000
UNION ALL
SELECT
	t1.PERIOD,
	t2.PERIOD AS PERIOD1,
	t2.SCENARIO,
	t2.ENTITY_CODE,
	t2.CFC_ENTITY_CODE,
	t2.CFC_EARNINGS,
	t2.DATA_TYPE
FROM CTE_PERIOD t1
JOIN PROFIT0 t2 ON t1.PERIOD = t2.PERIOD
--WHERE ROWNUM <= 1000000
)INSERT INTO TEMP_TRS_FACT_CFC_INV_INCOME1 SELECT *,GETDATE() AS UPDATED_TIME FROM PROFIT
END;

CREATE PROCEDURE P_TEMP_TRS_FACT_CFC_INV_INCOME2 AS 
BEGIN 
	SELECT GETDATE() AS UPDATE_TIME;
	TRUNCATE TABLE TEMP_TRS_FACT_CFC_INV_INCOME2;
;WITH CTE_VERSION AS (
SELECT DISTINCT
	SCENARIO
FROM TRS_FACT_CFC_ENTITY_VERSION_SCENARIO
),CTE_HEAD AS (
SELECT DISTINCT
	PERIOD,
	SCENARIO,
	ENTITY_CODE
FROM V_TRS_FACT_CFC_ENTITY_VERSION
),CTE_PERIOD AS (
SELECT DISTINCT
	PERIOD
FROM TRS_FACT_CFC_ENTITY_VERSION_PERIOD
),CTE_DIVIDEND_CUR AS (
SELECT
	t1.FISCAL_YEAR,
	t2.CURRENT_CODE AS ENTITY_CODE,
	t3.CURRENT_CODE AS CFC_ENTITY_CODE,
	t1.CURRENCY_ID,
	t1.SCENARIO,
	t1.DECLARATION_DATE,
	t1.NON_CHINA_DIVIDEND_PROFIT,
	t1.CHINA_DIVIDEND_PROFIT
FROM TRS_FACT_CFC_DIVIDEND T1
LEFT JOIN V_TRS_DIM_ENTITY_CUR T2 ON T1.ENTITY_CODE = T2.ENTITY_CODE 
LEFT JOIN V_TRS_DIM_ENTITY_CUR T3 ON T1.CFC_ENTITY_CODE = T3.ENTITY_CODE 
)
, CTE_DIVIDEND1 AS (
SELECT
	t2.FISCAL_YEAR,
	t1.period,
	t2.ENTITY_CODE,
	t2.CFC_ENTITY_CODE,
	t2.CURRENCY_ID,
	t1.SCENARIO,
	t2.DECLARATION_DATE,
	t2.NON_CHINA_DIVIDEND_PROFIT,
	t2.CHINA_DIVIDEND_PROFIT
FROM CTE_HEAD t1
LEFT JOIN CTE_DIVIDEND_CUR t2 ON t1.ENTITY_CODE = t2.ENTITY_CODE
WHERE t2.SCENARIO = 'Per Audit' AND t2.DECLARATION_DATE < DATEFROMPARTS(YEAR(t1.period), 1, 1)
UNION ALL
SELECT
	t2.FISCAL_YEAR,
	t1.period,
	t2.ENTITY_CODE,
	t2.CFC_ENTITY_CODE,
	t2.CURRENCY_ID,
	t1.SCENARIO,
	t2.DECLARATION_DATE,
	t2.NON_CHINA_DIVIDEND_PROFIT,
	t2.CHINA_DIVIDEND_PROFIT
FROM CTE_HEAD t1
LEFT JOIN CTE_DIVIDEND_CUR t2 ON t1.ENTITY_CODE = t2.ENTITY_CODE AND t1.SCENARIO = t2.SCENARIO
WHERE t2.DECLARATION_DATE BETWEEN DATEFROMPARTS(YEAR(t1.period), 1, 1) AND t1.PERIOD
)
/*, CTE_DIVIDEND1 AS (
SELECT
	t1.PERIOD,
	t2.DECLARATION_DATE AS PERIOD1,
	t1.SCENARIO,
	t2.CURRENCY_ID,
	t2.ENTITY_CODE,
	t2.CFC_ENTITY_CODE,
	t2.DECLARATION_DATE,
	t2.FISCAL_YEAR,
	t2.NON_CHINA_DIVIDEND_PROFIT,
	t2.CHINA_DIVIDEND_PROFIT
FROM CTE_HEAD t1
JOIN CTE_DIVIDEND0 t2 ON t1.PERIOD > t2.DECLARATION_DATE AND t1.SCENARIO = t2.SCENARIO AND t1.ENTITY_CODE = t2.CFC_ENTITY_CODE
UNION ALL
SELECT
	t1.PERIOD,
	t2.DECLARATION_DATE AS PERIOD1,
	t2.SCENARIO,
	t2.CURRENCY_ID,
	t2.ENTITY_CODE,
	t2.CFC_ENTITY_CODE,
	t2.DECLARATION_DATE,
	t2.FISCAL_YEAR,
	t2.NON_CHINA_DIVIDEND_PROFIT,
	t2.CHINA_DIVIDEND_PROFIT
FROM CTE_PERIOD t1
JOIN CTE_DIVIDEND0 t2 ON t1.PERIOD = t2.DECLARATION_DATE
)--SELECT * FROM CTE_DIVIDEND1*/
,DIVIDEND AS (
SELECT
	t1.PERIOD,
	t1.DECLARATION_DATE AS PERIOD1,
	t1.DECLARATION_DATE,
	t1.SCENARIO,
	t1.FISCAL_YEAR,
	t1.ENTITY_CODE,
	t1.CFC_ENTITY_CODE,
	t1.NON_CHINA_DIVIDEND_PROFIT * t2.RATIO_HOLD * CASE WHEN t1.DECLARATION_DATE<= DATEFROMPARTS(YEAR(GETDATE()), 1, 1) THEN t5.AVG_EXCHANGE_RATIO
		WHEN YEAR(t1.PERIOD) > t1.FISCAL_YEAR THEN t3.AVG_EXCHANGE_RATIO ELSE t4.AVG_EXCHANGE_RATIO END AS DIVIDEND,
	'DIVIDEND' AS DATA_TYPE,
	'0' AS CHINA
FROM CTE_DIVIDEND1 t1
LEFT JOIN TRS_FACT_GROUP_INV_REL t2 ON t1.CFC_ENTITY_CODE = t2.INV_ENTITY_CODE AND t1.ENTITY_CODE = t2.ENTITY_CODE AND t1.DECLARATION_DATE BETWEEN t2.START_DATE AND t2.END_DATE
LEFT JOIN V_TRS_FACT_EXCHANGE_BANKOFTW t3 ON t1.CURRENCY_ID = t3.CURRENCY_ID AND t3.TARGET_CURRENCY_ID = 'NTD' AND t1.SCENARIO = t3.SCENARIO AND t1.FISCAL_YEAR + '-12' = t3.PERIOD
LEFT JOIN V_TRS_FACT_EXCHANGE_BANKOFTW t4 ON t1.CURRENCY_ID = t4.CURRENCY_ID AND t4.TARGET_CURRENCY_ID = 'NTD' AND t1.SCENARIO = t4.SCENARIO AND t1.PERIOD = t4.PERIOD_DATE
LEFT JOIN V_TRS_FACT_EXCHANGE_BANKOFTW t5 ON t1.CURRENCY_ID = t5.CURRENCY_ID AND t5.TARGET_CURRENCY_ID = 'NTD' AND t5.SCENARIO = 'Per Audit' AND t1.FISCAL_YEAR + '-12' = t5.PERIOD
WHERE NON_CHINA_DIVIDEND_PROFIT IS NOT NULL AND NON_CHINA_DIVIDEND_PROFIT > 0
UNION ALL
SELECT
	t1.PERIOD,
	t1.DECLARATION_DATE AS PERIOD1,
	t1.DECLARATION_DATE,
	t1.SCENARIO,
	t1.FISCAL_YEAR,
	t1.ENTITY_CODE,
	t1.CFC_ENTITY_CODE,
	t1.CHINA_DIVIDEND_PROFIT * t2.RATIO_HOLD * CASE WHEN t1.DECLARATION_DATE<= DATEFROMPARTS(YEAR(GETDATE()), 1, 1) THEN t5.AVG_EXCHANGE_RATIO
		WHEN YEAR(t1.PERIOD) > t1.FISCAL_YEAR THEN t3.AVG_EXCHANGE_RATIO ELSE t4.AVG_EXCHANGE_RATIO END AS DIVIDEND,
	'DIVIDEND' AS DATA_TYPE,
	'1' AS CHINA
FROM CTE_DIVIDEND1 t1
LEFT JOIN TRS_FACT_GROUP_INV_REL t2 ON t1.CFC_ENTITY_CODE = t2.INV_ENTITY_CODE AND t1.ENTITY_CODE = t2.ENTITY_CODE AND t1.DECLARATION_DATE BETWEEN t2.START_DATE AND t2.END_DATE
LEFT JOIN V_TRS_FACT_EXCHANGE_BANKOFTW t3 ON t1.CURRENCY_ID = t3.CURRENCY_ID AND t3.TARGET_CURRENCY_ID = 'NTD' AND t1.SCENARIO = t3.SCENARIO AND t1.FISCAL_YEAR + '-12' = t3.PERIOD
LEFT JOIN V_TRS_FACT_EXCHANGE_BANKOFTW t4 ON t1.CURRENCY_ID = t4.CURRENCY_ID AND t4.TARGET_CURRENCY_ID = 'NTD' AND t1.SCENARIO = t4.SCENARIO AND t1.PERIOD = t4.PERIOD_DATE
LEFT JOIN V_TRS_FACT_EXCHANGE_BANKOFTW t5 ON t1.CURRENCY_ID = t5.CURRENCY_ID AND t5.TARGET_CURRENCY_ID = 'NTD' AND t5.SCENARIO = 'Per Audit' AND t1.FISCAL_YEAR + '-12' = t5.PERIOD
WHERE CHINA_DIVIDEND_PROFIT IS NOT NULL AND CHINA_DIVIDEND_PROFIT > 0
)--SELECT * FROM DIVIDEND
, SECURITY_CUR AS(
SELECT 
t1.INV_SECURITY_CODE,
t2.CURRENT_CODE
FROM TRS_DIM_INV_SECURITY t1
LEFT JOIN V_TRS_DIM_ENTITY_CUR T2 ON T1.CORR_COMPANY_ID = T2.ENTITY_CODE
),CTE_INV_DETAIL AS (
SELECT
	T1.PERIOD,
	T2.CURRENT_CODE AS ENTITY_CODE,
	ISNULL(T3.CURRENT_CODE, t1.INV_SECURITY_CODE) AS INV_SECURITY_CODE,
	INV_ADJITEM_CODE,
	CAST(SHARE_QTY AS FLOAT) AS SHARE_QTY
FROM TRS_FACT_INV_DETAIL T1
LEFT JOIN V_TRS_DIM_ENTITY_CUR T2 ON T1.ENTITY_CODE = T2.ENTITY_CODE
LEFT JOIN SECURITY_CUR T3 ON T1.INV_SECURITY_CODE = T3.INV_SECURITY_CODE
)
,SHARES AS (
SELECT
	PERIOD,
	ENTITY_CODE,
	INV_SECURITY_CODE AS CFC_ENTITY_CODE,
	INV_ADJITEM_CODE,
	SHARE_QTY,
	'SHARES' AS DATA_TYPE
FROM CTE_INV_DETAIL
),SHARE_ORD AS(
	SELECT 
	ROW_NUMBER()OVER(PARTITION BY ENTITY_CODE,CFC_ENTITY_CODE ORDER BY PERIOD) AS ORDERS,
	PERIOD, ENTITY_CODE, CFC_ENTITY_CODE, INV_ADJITEM_CODE, SHARE_QTY, DATA_TYPE
	FROM SHARES
),SHARE_CHANGE(ORDERS, PERIOD, ENTITY_CODE,CFC_ENTITY_CODE,SHARE_QTY,ACC_SHARES,CHANGES,INV_ADJITEM_CODE, DATA_TYPE) AS(
SELECT 
	ORDERS,
	PERIOD, ENTITY_CODE,CFC_ENTITY_CODE,SHARE_QTY,
	0+SHARE_QTY AS ACC_SHARES,
	CAST(NULL AS FLOAT) AS CHANGES,
	INV_ADJITEM_CODE,
	DATA_TYPE
FROM SHARE_ORD 
WHERE ORDERS = 1
UNION ALL
SELECT 
	t.ORDERS,
	t.PERIOD, t.ENTITY_CODE,t.CFC_ENTITY_CODE,t.SHARE_QTY,
	t.SHARE_QTY+SHARE_CHANGE.ACC_SHARES AS ACC_SHARES,
	CASE WHEN SHARE_CHANGE.ACC_SHARES IS NULL OR SHARE_CHANGE.ACC_SHARES = 0 THEN 0 ELSE t.SHARE_QTY/SHARE_CHANGE.ACC_SHARES END AS CHANGES,
	t.INV_ADJITEM_CODE,
	t.DATA_TYPE
FROM SHARE_ORD t
JOIN SHARE_CHANGE ON t.ORDERS = SHARE_CHANGE.orders+1 AND t.ENTITY_CODE = SHARE_CHANGE.ENTITY_CODE AND t.CFC_ENTITY_CODE = SHARE_CHANGE.CFC_ENTITY_CODE
)
, SHARE_PERC AS (
SELECT
--	t2.ORDERS,
	t1.PERIOD,
	t2.PERIOD AS PERIOD1,
	t2.ENTITY_CODE,
	t2.CFC_ENTITY_CODE,SHARE_QTY,
	t2.ACC_SHARES,
	t2.CHANGES, 
	t2.INV_ADJITEM_CODE,
	t2.DATA_TYPE
FROM CTE_PERIOD t1
LEFT JOIN SHARE_CHANGE t2 ON t1.PERIOD > t2.PERIOD
WHERE CHANGES<0 AND t2.INV_ADJITEM_CODE LIKE 'disposed_%'
UNION ALL
SELECT
--	t2.ORDERS,
	t1.PERIOD,
	t2.PERIOD AS PERIOD1,
	t2.ENTITY_CODE,
	t2.CFC_ENTITY_CODE,SHARE_QTY,
	t2.ACC_SHARES,
	t2.CHANGES, 
	t2.INV_ADJITEM_CODE,
	t2.DATA_TYPE
FROM CTE_PERIOD t1
LEFT JOIN SHARE_CHANGE t2 ON t1.PERIOD = t2.PERIOD
WHERE CHANGES<0 AND INV_ADJITEM_CODE LIKE 'disposed_%'
), SHARE_PERC1 AS (
SELECT
	T1.PERIOD,
	T1.SCENARIO,
	t2.PERIOD1,
	t2.ENTITY_CODE,
	t2.CFC_ENTITY_CODE,SHARE_QTY,
	t2.ACC_SHARES,
	t2.CHANGES, 
	t2.INV_ADJITEM_CODE,
	t2.DATA_TYPE
FROM CTE_HEAD T1
JOIN SHARE_PERC T2 ON T1.PERIOD = T2.PERIOD AND T1.ENTITY_CODE = T2.ENTITY_CODE
)--SELECT * FROM SHARE_PERC
,FISCAL_YEAR AS(
SELECT DISTINCT 
	PERIOD, SCENARIO,                                 
	YEAR(PERIOD1) AS FISCAL_YEAR
FROM TEMP_TRS_FACT_CFC_INV_INCOME1
WHERE CFC_EARNINGS > 0
),T AS(
SELECT 
	FISCAL_YEAR,
	t2.PERIOD,
	t2.PERIOD1,
	T1.SCENARIO ,
	ENTITY_CODE ,
	CFC_ENTITY_CODE,
	NULL AS AMOUNT,
	CHANGES,
	t2.DATA_TYPE,
	NULL AS CHINA
FROM FISCAL_YEAR t1
JOIN SHARE_PERC1 t2 ON t1.PERIOD = t2.PERIOD AND t2.PERIOD IS NOT NULL AND T1.SCENARIO = T2.SCENARIO
--
UNION ALL 
SELECT 
	YEAR(PERIOD1) AS FISCAL_YEAR,
	PERIOD,
	PERIOD1,
	SCENARIO ,
	ENTITY_CODE,
	CFC_ENTITY_CODE,
	CFC_EARNINGS AS AMOUNT,
	NULL AS DELTA_CHANGE,
	DATA_TYPE,
	NULL AS CHINA
FROM TEMP_TRS_FACT_CFC_INV_INCOME1
--
UNION ALL
SELECT
	FISCAL_YEAR,
	PERIOD,
	PERIOD1,
	SCENARIO,
	ENTITY_CODE,
	CFC_ENTITY_CODE,
	DIVIDEND*-1 AS DIVIDEND,
	NULL AS DELTA_CHANGE,
	DATA_TYPE,
	CHINA
FROM DIVIDEND
)INSERT INTO TEMP_TRS_FACT_CFC_INV_INCOME2 SELECT *,GETDATE() AS UPDATED_TIME  FROM T
END;

CREATE PROCEDURE P_TRS_FACT_CFC_RECOGNIZED_AMOUNT AS
BEGIN 
SELECT GETDATE() AS UPDATE_TIME;
TRUNCATE TABLE TEMP_TRS_FACT_CFC_RECOGNIZED_AMOUNT;
WITH CTE AS (
SELECT
	t1.PERIOD,
	t1.ENTITY_CODE,
	t1.INV_ENTITY_CODE,
	SUM(AVG_RATIO_HOLD) AS RATIO_HOLD
FROM V_TRS_FACT_CFC_RATIO_HOLD t1
JOIN TRS_FACT_CFC_ENTITY_VERSION_TAX t3 ON t1.COUNTRY_ID = t3.COUNTRY_ID AND t3.IS_LOWTAX = 'true' AND t1.PERIOD = t3.PERIOD
GROUP BY T1.PERIOD, t1.ENTITY_CODE, INV_ENTITY_CODE,t3.IS_LOWTAX
)
, stock_ratio (PERIOD, base_entity, inv_entity, ratio,  depth) AS (
  --初始化所有基本關係
  SELECT PERIOD, ENTITY_CODE, INV_ENTITY_CODE, RATIO_HOLD,  1
  FROM CTE
  UNION ALL
  -- 遞歸擴展關係
  SELECT t1.PERIOD, t1.base_entity, t2.INV_ENTITY_CODE, t1.ratio * t2.RATIO_HOLD, 
         t1.depth + 1
  FROM stock_ratio t1
  JOIN CTE t2 ON t1.inv_entity = t2.ENTITY_CODE AND t1.PERIOD = t2.PERIOD  --AND t2.IS_LOWTAX = 'true'
  WHERE t1.depth <= 20 -- 限制遞歸深度以防止無限循環
)
,CTE2 AS (
SELECT PERIOD, 
base_entity, 
inv_entity, 
ratio, 
DEPTH
FROM stock_ratio
),CTE_HEAD AS (
SELECT 
	PERIOD,
	BASE_ENTITY,
	INV_ENTITY,
	SUM(RATIO) AS RATIO,
	GETDATE() AS UPDATED_TIME
FROM CTE2
GROUP BY PERIOD, BASE_ENTITY, INV_ENTITY
)
INSERT INTO TEMP_TRS_FACT_CFC_RECOGNIZED_AMOUNT SELECT * FROM CTE_HEAD
END;

CREATE PROCEDURE P_TRIGGER_ENTITY_CUR AS
BEGIN
TRUNCATE TABLE V_TRS_DIM_ENTITY_CUR;
WITH CTE AS (
    -- 基礎查詢，從 IS_ACTIVE = 'true' 的節點開始
    SELECT 
        ENTITY_CODE,
        ENTITY_CODE AS current_code,
        COUNTRY_ID,
        CURRENCY_ID,
        IS_ACTIVE,
        IS_ACTIVE AS SHOW,
        ENTITY_TYPE_ID,
        PRE_CODE
    FROM TRS_DIM_ENTITY 
    WHERE IS_ACTIVE = 'true'
    UNION ALL
    -- 遞迴部分，尋找子節點
    SELECT 
        t.ENTITY_CODE,
        c.current_code, -- 保持遞迴開始的起點 ENTITY_CODE 不變
        t.COUNTRY_ID,
        t.CURRENCY_ID,
        t.IS_ACTIVE,
        t.IS_ACTIVE AS SHOW,
        t.ENTITY_TYPE_ID,
        t.PRE_CODE
    FROM TRS_DIM_ENTITY t
    JOIN CTE c ON c.PRE_CODE = t.ENTITY_CODE
    WHERE c.pre_code IS NOT NULL AND t.IS_ACTIVE ='false'
),CTE_RES AS (
SELECT 
    ENTITY_CODE,
    current_code,
    COUNTRY_ID,
    CURRENCY_ID,
    IS_ACTIVE,
    SHOW,
    ENTITY_TYPE_ID
FROM CTE
UNION ALL
SELECT
t1.ENTITY_CODE,
t1.ENTITY_CODE AS CURRENT_CODE,
t1.COUNTRY_ID,
t1.CURRENCY_ID,
t1.IS_ACTIVE,
'true' AS SHOW,
t1.ENTITY_TYPE_ID
FROM TRS_DIM_ENTITY t1
LEFT JOIN TRS_DIM_ENTITY t2 ON t2.PRE_CODE =t1.ENTITY_CODE
WHERE t1.IS_ACTIVE = 'false' AND t2.PRE_CODE IS NULL
UNION ALL 
--加入權益法公司
SELECT 
ENTITY_CODE,
ENTITY_CODE AS CURRENT_CODE,
CAST(COUNTRY_CODE AS VARCHAR(36)) AS COUNTRY_ID, 
LOCAL_CURRENCY AS CURRENCY_ID,
'true' AS IS_ACTIVE,
'true' AS SHOW,
'003' AS ENTITY_TYPE_ID
FROM TRS_DIM_EQUITY_INV_LIST)
INSERT INTO V_TRS_DIM_ENTITY_CUR
SELECT * FROM CTE_RES
END;

CREATE PROCEDURE P_TRIGGER_EXCHANGE_BANKOFTW AS 
BEGIN
TRUNCATE TABLE V_TRS_FACT_EXCHANGE_BANKOFTW;
WITH CTE AS(
   SELECT 
    period,
    CURRENCY_ID,
    CURRENCY_ID AS TARGET_CURRENCY_ID,
    SCENARIO
	FROM TRS_FACT_EXCHANGE_BANKOFTW  t1
	UNION ALL
	  SELECT 
    period,
    TARGET_CURRENCY_ID AS CURRENCY_ID,
    TARGET_CURRENCY_ID,
    SCENARIO
	FROM TRS_FACT_EXCHANGE_BANKOFTW
	),CTE_RES AS (
  SELECT
    period,
    CURRENCY_FACT_ID,
    CURRENCY_ID,
    TARGET_CURRENCY_ID,
    SUBSTRING(PERIOD,1,4) AS YEAR,
    SUBSTRING(PERIOD,6,2) AS MONTH,
    exchange_ratio,
	AVG(exchange_ratio) over(PARTITION BY SUBSTRING(PERIOD,1,4),t.CURRENCY_ID,t.TARGET_CURRENCY_ID,t.SCENARIO order by t.period) as AVG_EXCHANGE_RATIO,
    SCENARIO,
	CREATED_BY,
	CREATED_TIME,
	UPDATED_TIME,
	UPDATED_BY,
	EOMONTH(PERIOD + '-01') AS PERIOD_DATE
  FROM TRS_FACT_EXCHANGE_BANKOFTW t
  UNION ALL
  SELECT DISTINCT
    period,
    NULL AS CURRENCY_FACT_ID,
    CURRENCY_ID,
    TARGET_CURRENCY_ID,
    SUBSTRING(PERIOD,1,4) AS YEAR,
    SUBSTRING(PERIOD,6,2) AS MONTH,
    1 AS exchange_ratio,
	1 AS AVG_EXCHANGE_RATIO,
    SCENARIO,
	NULL AS CREATED_BY,
	NULL AS CREATED_TIME,
	NULL AS UPDATED_TIME,
	NULL AS UPDATED_BY,
	EOMONTH(PERIOD + '-01') AS PERIOD_DATE
	FROM CTE)
INSERT INTO V_TRS_FACT_EXCHANGE_BANKOFTW
SELECT * FROM CTE_RES
END;

CREATE PROCEDURE P_TRIGGER_TAX AS
BEGIN
SELECT GETDATE() AS UPDATE_TIME;
TRUNCATE TABLE TRS_FACT_CFC_ENTITY_VERSION_TAX;
WITH CTE_RES AS (
SELECT 
t1.PERIOD ,
t2.COUNTRY_CODE ,
t2.IS_LOWTAX ,
t2.TAX_RATE 
FROM
TRS_FACT_CFC_ENTITY_VERSION_PERIOD t1
LEFT JOIN TRS_FACT_COUNTRY_TAX t2 ON t1.PERIOD between t2.START_DATE AND t2.END_DATE 
)
INSERT INTO TRS_FACT_CFC_ENTITY_VERSION_TAX SELECT * FROM CTE_RES
END;